#!/usr/bin/env -S dotnet fsi

open System
open System.IO
open System.Text
open System.Collections.Generic

type DbfFieldType =
    | Character of int
    | Numeric of int * int
    | Date
    | Logical
    | Memo
    | Float of int * int
    | Currency
    | Integer
    | DateTime
    | Unknown of char

type DbfField = {
    Name: string
    FieldType: DbfFieldType
    Length: int
    DecimalCount: int
}

type DbfHeader = {
    Version: byte
    LastUpdate: DateTime
    RecordCount: int
    HeaderLength: int
    RecordLength: int
    Fields: DbfField list
}

let readDbfHeader (filePath: string) : DbfHeader =
    use fs = new FileStream(filePath, FileMode.Open, FileAccess.Read)
    use reader = new BinaryReader(fs)
    
    let version = reader.ReadByte()
    
    let year = 1900 + int(reader.ReadByte())
    let month = int(reader.ReadByte())
    let day = int(reader.ReadByte())
    let lastUpdate = DateTime(year, month, day)
    
    let recordCount = reader.ReadInt32()
    let headerLength = reader.ReadInt16()
    let recordLength = reader.ReadInt16()
    
    reader.BaseStream.Seek(32L, SeekOrigin.Begin) |> ignore
    
    let fields = ResizeArray<DbfField>()
    let mutable fieldStart = 32
    
    while fieldStart < headerLength - 1 do
        reader.BaseStream.Seek(int64 fieldStart, SeekOrigin.Begin) |> ignore
        
        let nameBytes = reader.ReadBytes(11)
        let nullIndex = Array.FindIndex(nameBytes, fun b -> b = 0uy)
        let name = 
            if nullIndex >= 0 then
                Encoding.ASCII.GetString(nameBytes, 0, nullIndex)
            else
                Encoding.ASCII.GetString(nameBytes).TrimEnd([|char 0|])
        
        if name.Length > 0 then
            let fieldTypeChar = reader.ReadChar()
            reader.BaseStream.Seek(4L, SeekOrigin.Current) |> ignore
            let length = int(reader.ReadByte())
            let decimalCount = int(reader.ReadByte())
            
            let fieldType =
                match fieldTypeChar with
                | 'C' -> Character length
                | 'N' -> Numeric(length, decimalCount)
                | 'D' -> Date
                | 'L' -> Logical
                | 'M' -> Memo
                | 'F' -> Float(length, decimalCount)
                | 'Y' -> Currency
                | 'I' -> Integer
                | 'T' -> DateTime
                | c -> Unknown c
            
            fields.Add({
                Name = name
                FieldType = fieldType
                Length = length
                DecimalCount = decimalCount
            })
        
        fieldStart <- fieldStart + 32
    
    {
        Version = version
        LastUpdate = lastUpdate
        RecordCount = recordCount
        HeaderLength = headerLength
        RecordLength = recordLength
        Fields = fields |> List.ofSeq
    }

let parseDbfFieldTypeToSql (field: DbfField) =
    match field.FieldType with
    | Character n -> 
        if n <= 255 then sprintf "VARCHAR(%d)" n
        else "TEXT"
    | Numeric(l, d) ->
        if d = 0 then
            if l <= 4 then "SMALLINT"
            elif l <= 9 then "INTEGER"
            else "BIGINT"
        else
            sprintf "DECIMAL(%d,%d)" l d
    | Date -> "DATE"
    | Logical -> "BOOLEAN"
    | Memo -> "TEXT"
    | Float(l, d) -> sprintf "DECIMAL(%d,%d)" l d
    | Currency -> "DECIMAL(19,4)"
    | Integer -> "INTEGER"
    | DateTime -> "TIMESTAMP"
    | Unknown c -> sprintf "VARCHAR(255) /* Unknown type: %c */" c

type MdxTag = {
    Name: string
    KeyExpression: string
    ForExpression: string option
    Unique: bool
    Descending: bool
}

let parseMdxFile (mdxPath: string) : MdxTag list =
    if not (File.Exists(mdxPath)) then
        []
    else
        try
            use fs = new FileStream(mdxPath, FileMode.Open, FileAccess.Read)
            use reader = new BinaryReader(fs)
            
            let signature = reader.ReadByte()
            if signature <> 0x02uy then
                printfn "Warning: MDX file signature not recognized (0x%02X)" signature
                []
            else
                reader.BaseStream.Seek(28L, SeekOrigin.Begin) |> ignore
                let tagCount = reader.ReadInt16()
                
                let tags = ResizeArray<MdxTag>()
                
                reader.BaseStream.Seek(544L, SeekOrigin.Begin) |> ignore
                
                for i in 0 .. int(tagCount) - 1 do
                    let tagStart = 544L + int64(i * 32)
                    reader.BaseStream.Seek(tagStart, SeekOrigin.Begin) |> ignore
                    
                    let nameBytes = reader.ReadBytes(11)
                    let nullIndex = Array.FindIndex(nameBytes, fun b -> b = 0uy)
                    let name = 
                        if nullIndex >= 0 then
                            Encoding.ASCII.GetString(nameBytes, 0, nullIndex)
                        else
                            Encoding.ASCII.GetString(nameBytes).TrimEnd([|char 0|])
                    
                    if name.Length > 0 && name <> "DELETED" then
                        tags.Add({
                            Name = name
                            KeyExpression = name
                            ForExpression = None
                            Unique = false
                            Descending = false
                        })
                
                tags |> List.ofSeq
        with ex ->
            printfn "Warning: Could not parse MDX file: %s" ex.Message
            []

let generateSqlSchema (tableName: string) (header: DbfHeader) (indexes: MdxTag list) =
    let sb = StringBuilder()
    
    sb.AppendLine("-- Generated from DBF schema") |> ignore
    sb.AppendLine(sprintf "-- Table: %s" tableName) |> ignore
    sb.AppendLine(sprintf "-- Last Updated: %s" (header.LastUpdate.ToString("yyyy-MM-dd"))) |> ignore
    sb.AppendLine(sprintf "-- Record Count: %d" header.RecordCount) |> ignore
    sb.AppendLine() |> ignore
    
    sb.AppendLine(sprintf "CREATE TABLE %s (" tableName) |> ignore
    
    let fieldLines = 
        header.Fields 
        |> List.map (fun field ->
            let sqlType = parseDbfFieldTypeToSql field
            sprintf "    %s %s" field.Name sqlType
        )
    
    sb.AppendLine(String.Join(",\n", fieldLines)) |> ignore
    sb.AppendLine(");") |> ignore
    
    if not (List.isEmpty indexes) then
        sb.AppendLine() |> ignore
        sb.AppendLine("-- Indexes from MDX file") |> ignore
        for index in indexes do
            let indexType = if index.Unique then "UNIQUE " else ""
            let direction = if index.Descending then " DESC" else ""
            sb.AppendLine(sprintf "CREATE %sINDEX idx_%s_%s ON %s (%s%s);" 
                indexType tableName index.Name tableName index.KeyExpression direction) |> ignore
    
    sb.ToString()

let main (args: string[]) =
    if args.Length < 1 then
        printfn "Usage: extract-schema <dbf-file> [output-file]"
        printfn "Example: extract-schema tmp/STOC.DBF config/schema.sql"
        exit 1
    
    let dbfPath = args.[0]
    let outputPath = 
        if args.Length > 1 then args.[1]
        else "config/schema.sql"
    
    if not (File.Exists(dbfPath)) then
        printfn "Error: DBF file not found: %s" dbfPath
        exit 1
    
    try
        printfn "Reading DBF file: %s" dbfPath
        let header = readDbfHeader dbfPath
        
        let tableName = 
            Path.GetFileNameWithoutExtension(dbfPath).ToUpper()
        
        let mdxPath = Path.ChangeExtension(dbfPath, ".MDX")
        let indexes = 
            if File.Exists(mdxPath) then
                printfn "Reading MDX file: %s" mdxPath
                parseMdxFile mdxPath
            else
                printfn "No MDX file found, skipping indexes"
                []
        
        printfn "Found %d fields and %d indexes" header.Fields.Length indexes.Length
        
        let sql = generateSqlSchema tableName header indexes
        
        let outputDir = Path.GetDirectoryName(outputPath)
        if not (String.IsNullOrEmpty(outputDir)) && not (Directory.Exists(outputDir)) then
            Directory.CreateDirectory(outputDir) |> ignore
        
        File.WriteAllText(outputPath, sql)
        printfn "Schema exported to: %s" outputPath
        
        printfn "\nField Summary:"
        for field in header.Fields do
            let sqlType = parseDbfFieldTypeToSql field
            printfn "  %s: %s" field.Name sqlType
        
        0
    with ex ->
        printfn "Error: %s" ex.Message
        1

main fsi.CommandLineArgs.[1..]